
<!doctype html>
<html lang="zh">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <title>XD.Wang的技术博客</title>
    <!-- Load CSS -->
    <link href="/assets/tech/css/style.css" rel="stylesheet" type="text/css"/>
    <!-- Load jQuery library -->
    <script type="text/javascript" src="/assets/tech/scripts/jquery-1.6.2.min.js"></script>
    <!-- Load custom js -->
    <script type="text/javascript" src="/assets/tech/scripts/panelslide.js"></script>
    <script type="text/javascript" src="/assets/tech/scripts/custom.js"></script>
    <!-- Load topcontrol js -->
    <script type="text/javascript" src="/assets/tech/scripts/scrolltopcontrol.js"></script>
    <!-- Load NIVO Slider -->
    <link rel="stylesheet" href="/assets/tech/css/nivo-slider.css" type="text/css" media="screen"/>
    <link rel="stylesheet" href="/assets/tech/css/nivo-theme.css" type="text/css" media="screen"/>
    <script src="/assets/tech/scripts/jquery.nivo.slider.pack.js" type="text/javascript"></script>
    <script src="/assets/tech/scripts/nivo-options.js" type="text/javascript"></script>
    <!-- Load fancybox -->
    <script type="text/javascript" src="/assets/tech/scripts/jquery.fancybox-1.3.4.pack.js"></script>
    <script type="text/javascript" src="/assets/tech/scripts/jquery.easing-1.3.pack.js"></script>
    <script type="text/javascript" src="/assets/tech/scripts/jquery.mousewheel-3.0.4.pack.js"></script>
    <link rel="stylesheet" href="/assets/tech/css/jquery.fancybox-1.3.4.css" type="text/css" media="screen"/>
</head>
<body>


<input type="hidden" value="BLOG" id="navType">

<!--This is the START of the header-->
<div id="topcontrol" style="position: fixed; bottom: 5px; left: 960px; opacity: 1; cursor: pointer;"
     title="Go to Top"></div>
<div id="header-wrapper">
    <div id="header">
        <div id="logo"><a href="/page/tech/blog-index-1.html"><img src="/assets/tech/images/logo.jpg" width="140"
                                                                   height="70"
                                                                   alt="logo"/></a></div>
        <div id="header-text">
            <h4>技术博客 Code Craft</h4>
            <h6>BLOG</h6>
        </div>
    </div>
</div>
<!--END of header-->
<!--This is the START of the menu-->
<div id="menu-wrapper">
    <div id="main-menu">
        <ul>
            <li><a id="nav-blog" href="/page/tech/blog-index-1.html">博客</a></li>
            <li><a id="nav-note" href="/page/tech/note-index-1.html">笔记</a></li>
            <li><a id="nav-fq" href="/page/tech/faq-index-1.html">问答</a></li>
            <li><a id="nav-digest" href="/page/tech/digest-index-1.html">文摘</a></li>
        </ul>
    </div>
</div>
<!--END of menu-->
<!--This is the START of the segment-->
<div id="content">
    <!--This is the START of the blog section-->
    <div id="blog">
        <div class="blog-item-single">
            <h1>数据库扩容技术概述</h1>
            <div class="blog-item-single-info">
                <div class="user">XD.Wang</div>
                <div class="tags">数据库</div>
            </div>
            <div class="blog-item-single-content"><a class="single_image" href="http://img.mp.itc.cn/upload/20161129/309082ea1b5a484bac7186fbcfde3060_th.jpg"><img
                    src="http://img.mp.itc.cn/upload/20161129/309082ea1b5a484bac7186fbcfde3060_th.jpg" width="720" height="280" alt="blog1"/></a>
                <div>
                    <h3 style="padding-top: 10px">前言</h3>
                    <hr>
                    <div>
                        <p style="font-size: 14px">&nbsp;&nbsp;&nbsp;数据库是大型网站架构中最容易达到性能瓶颈的组件之一，受制于内存限制，单个数据库能支持的并发连接数比较有限，当调整数据库最大连接数都无法解决业务场景时，就需要考虑数据库扩容了。（PS：IPV-4不考虑地址类型的情况下系统能支持的最大连接数理论上为2^48，但实际上由于每个Socket端口都需要占用15~20K的内存，实际能开启的连接只有主机内存/每个Socket端口的内存）。</p>
                    </div>
                </div>
                <div>
                    <h3 style="padding-top: 10px">机器升级</h3>
                    <hr>
                    <div>
                        <p style="font-size: 14px">&nbsp;&nbsp;&nbsp;这个策略没啥好说的，水平方向就是集群化，一台变多台；垂直就是换机器，4核变8核、8G变16G</p>
                    </div>
                </div>
                <div>
                    <h3 style="padding-top: 10px">读写分离</h3>
                    <hr>
                    <div>
                        <p style="font-size: 14px">&nbsp;&nbsp;&nbsp;数据库扩容一般从读写分离开始，对于相当一部分业务场景，如商品信息处理，都是读操作远大于写操作的，在读性能达到瓶颈时，适合对数据库进行读写分离。</p>
                    </div>
                    <div>
                        <p style="font-size: 14px">&nbsp;&nbsp;&nbsp;读写分离的实现原理是数据库的主从复制：组建数据库主从集群的好处是多机备份、容量扩充以及读写性能提升。在主从模型中，主库负责数据的读写，并将写结果通过binlog同步给从数据库。从库和主库会保持一个长连接，如果从库监测到了主库的binlog有变动，会将变动记录到自己的中继日志中，并由一个异步的SQL线程重放执行，以此实现数据同步。</p>
                    </div>
                    <div>
                        <p style="font-size: 14px">&nbsp;&nbsp;&nbsp;读写分离的数据源管理思路一般有两种：静态数据源路由（为主库定义一个数据源、为从库定义一个数据源）和动态切换数据源。</p>
                    </div>
                    <div>
                        <p style="font-size: 14px">&nbsp;&nbsp;&nbsp;数据源管理需借助Spring提供的AbstractRoutingDataSource类来完成。这个类内部有一个Map用来维护数据源信息，我们可以重写这个类，将读、写数据源注册到Map中，并重写determineCurrentLookupKey方法来动态加载需要调用的数据源；</p>
                    </div>
                    <div>
                        <p style="font-size: 14px">&nbsp;&nbsp;&nbsp;动态切换数据源的方法是，在每个请求流经Dao层时，通过AOP的方式动态传入用户选择的数据源给determine方法，从而实现动态切换。</p>
                    </div>
                    <div>
                        <p style="font-size: 14px">&nbsp;&nbsp;&nbsp;静态数据源路由也需重写determineCurrentLookupKey方法，但是它的切换不依赖于外界输入，逻辑是定死在determineCurrentLookupKey中的，如update、insert走主库、select走主从库。</p>
                    </div>
                </div>
                <div>
                    <h3 style="padding-top: 10px">分库分表</h3>
                    <hr>
                    <div>
                        <p style="font-size: 14px">&nbsp;&nbsp;&nbsp;分库分表可降低单机压力、超越单机资源造成的性能瓶颈。</p>
                    </div>
                    <div>
                        <p style="font-size: 14px">&nbsp;&nbsp;&nbsp;垂直切分：垂直分库分表根据业务划分多个库表，优点是业务清晰，易于分工维护，适合于多表分隔的情况</p>
                    </div>
                    <div>
                        <p style="font-size: 14px">&nbsp;&nbsp;&nbsp;水平切分：单表数据量过大的场景下，垂直分库对此无能无力，需要用到水平切分。水平分库的关键在于寻找路由键做分库依据，水平分库后单表的数据将大大减少，很好地提升了查询性能。</p>
                    </div>
                    <div>
                        <p style="font-size: 14px">&nbsp;&nbsp;&nbsp;垂直分库分别一般在架构设计之初就有所考虑，实践也比较简单，后面重点讨论下水平分库分表。</p>
                    </div>
                    <div>
                        <p style="font-size: 14px">&nbsp;&nbsp;&nbsp;困难：</p>
                    </div>
                    <div>
                        <p style="font-size: 14px">&nbsp;&nbsp;&nbsp;水平分库分表虽然原理简单，但实践时需要考虑不少细节问题，比如分布式事务、跨机器JOIN、跨节点聚合等问题，因此世面上出现了很多款强大的中间件支撑这种需求，比如阿里的TDDL、DRDS，当当出品的Sharding-JDBC等。</p>
                    </div>
                    <div>
                        <p style="font-size: 14px">&nbsp;&nbsp;&nbsp;事务：解决分布式事务主要依靠两种策略：a 补偿机制。若一致性要求不高，事务的每个操作都不考虑其他的操作的成功与否，每个操作需要做到自容错，通过检查或重试的方式保证自己最终一定会成功；b 两阶段提交。引入一个事务协调器，将事务过程分两步，预备和提交。所谓预备指的是事务协调器发起开始指令，所有机器都尝试执行自己机器的本地事务，但不执行提交操作；然后事务协调就收集所有参与者的本地事务执行情况，若都成功了则允许所有机器提交事务否则回滚； c 一阶段提交：从应用程序向数据库发出提交请求到数据库完成提交或回滚之后将结果返回给应用程序。</p>
                    </div>
                    <div>
                        <p style="font-size: 14px">&nbsp;&nbsp;&nbsp;跨节点JOIN：分隔为两次查询，子查询依据于主查询的结果。</p>
                    </div>
                    <div>
                        <p style="font-size: 14px">&nbsp;&nbsp;&nbsp;全局唯一ID：</p>
                    </div>
                    <div>
                        <p style="font-size: 14px">&nbsp;&nbsp;&nbsp;策略1：GUID是128位标识符，可借助现成工具生成，缺点是占地方</p>
                    </div>
                    <div>
                        <p style="font-size: 14px">&nbsp;&nbsp;&nbsp;策略2：通过一张带有唯一索引的表来维护一个ID池，缺点是需要额外写代码且频繁访问表会使表成为性能瓶颈。</p>
                    </div>
                    <div>
                        <p style="font-size: 14px">&nbsp;&nbsp;&nbsp;策略3：联合主键。使用机器号+表ID来组成联合主键，缺点是不利于关联查询，需要用俩字段进行关联</p>
                    </div>
                    <div>
                        <p style="font-size: 14px">&nbsp;&nbsp;&nbsp;策略4：ID分片。为每个集群分配一个起始自增位置，每张表从不同的起始位置开始自增，缺点是需要高度关注ID变化情况，且段满了不好处理。</p>
                    </div>
                    <div>
                        <p style="font-size: 14px">&nbsp;&nbsp;&nbsp;策略5：ID跳跃。为每个表分配一个不同的起始位置，然后设置一个大于集群机器数（需要考虑未来情况）的步长。eg：3张表起始点分别为1，2，3，步长为4，那么生成的ID分别是[1, 5, 9, 13...]、[2, 6, 10, 14...]、[3, 7, 11, 15...]</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!--END of blog section-->
</div>
</body>
<script type="application/javascript">
    $(function () {
        var navType = $("#navType").val();
        if (navType === "BLOG") {
            $("#nav-blog").addClass("selected").append(" -> ");
        } else if (navType === "NOTE") {
            $("#nav-note").addClass("selected").append(" -> ");

        } else if (navType === "FAQ") {
            $("#nav-fq").addClass("selected").append(" -> ");

        } else if (navType === "DIGEST") {
            $("#nav-digest").addClass("selected").append(" -> ");

        }
    });
</script>
</html>