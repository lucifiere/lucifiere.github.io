<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <!-- title -->
    <title>王贤兑的技术博客</title>

    <!-- meta -->
    <meta charset="UTF-8">

    <!-- links -->
    <link rel="stylesheet" type="text/css" media="screen" href="../../../css/style.css">

    <!-- scripts -->

    <!-- IE Hacks -->
    <!--[if IE]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
</head>
<body class="home blog">

<!-- header -->
<header>
    <div id="light">
        <div class="container_16">
            <h1 class="grid_8" style="font-size: 45px"><a href="../../../index.html">Code Craft Of XD.Wang</a></h1>
            <nav class="grid_8">
                <ul id="menu-menu" class="menu">
                    <li><a href="../../../index.html">主页</a></li>
                    <li><a href="../../../page/list/blog.html">博客</a></li>
                    <li><a href="../../../page/list/me.html">ME</a></li>
                </ul>
            </nav>
        </div>
    </div>
</header>
<div class="copyrights">作者：王贤兑</div>

<!-- wrapper -->
<div id="wrapper">
    <div class="container_16">
        <section id="posts" class="prefix_1 grid_9">

            <article>
                <h2>Spark快速入门</h2>
                <p class="info">March 6th, 2017 | by <span><a href="#" rel="author">XD.Wang</a></span> | bigdata
                </p>
                <div class="time"><p>Mar<br><span>6</span></p></div>

                <p></p>

                <div class="text">
                    <p><img src="../../../images/article/bigdata/1-1.jpg" height="250" width="510"></p>
                    <h4>概述</h4>
                    <p>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spark是当前最流行的分布式计算框架之一，它能完美整合到Hadoop生态系统，
                        替代Hadoop MapReduce进行分布式运算。Spark最重要的特点之一是能够在内存中进行计算，这样
                    </p>
                    <h4>RDD(Resilient Distributed Datasets)</h4>
                    <p>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spark支持Scala、Python和Java三种语言，本文整理了常用的Java API，以及Spark应用的基本编程思路。
                        Spark用RDD（弹性分布式数据模型）来组织数据，通过操作RDD实现数据处理计算。所谓的RDD，可近似看做一个只读数组。
                        通过数据源或RDD操作，可以创建一个RDD，无论是文件系统（HDFS、本地文件系统）、数据库（Hive、MySQL），还是内存数据结构（编程语言集合），
                        均可作为创建RDD的数据来源。RDD创建后，处理的结果可存储在内存或硬盘之中，具体存储方案可通过Storage Level类来设定。
                    </p>
                    <h4>RDD 操作</h4>
                    <p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RDD操作可以分为两大类：转化操作（包括单元素转化和键值对转化）和行动操作，转化操作可生成一个新的RDD对象，
                        行动操作将触发一次任务提交，一般会返回一个值，或执行存储操作。需要注意的是，转化操作是惰性操作，只有当任务提交时转化操作才会真正执行，
                        并且每次任务提交都会使整个RDD转化从头进行，因此，若要复用之前的提交结果，需要预先进行persist操作。</p>
                    <p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RDD转化操作（单元素）包括：</p>
                    <ol>
                        <li><b>map：</b>将函数作用于RDD的每个元素上，并返回新的RDD</li>
                        <li><b>flatMap：</b>将函数作用于RDD的每个元素上，并将数据拆分，拆分的各行具有相应的迭代器，返回新的RDD（元素是迭代器）</li>
                        <li><b>filter：</b>将函数作用于RDD的每个元素上，过滤掉不符合条件的元素，返回新的RDD</li>
                        <li><b>distinct：</b>去重，返回新的RDD</li>
                        <li><b>union：</b>合并两个ADD所有元素，返回新的RDD</li>
                        <li><b>intersection：</b>求出交集，返回新的RDD</li>
                        <li><b>subtract：</b>求差集，调用集合减去参数集合，返回新的RDD</li>
                        <li><b>cartesian：</b>求笛卡尔积，返回新的RDD</li>
                        <li><b>groupBy：</b>根据函数生成键，并按照键分组，返回新的键值RDD</li>
                    </ol>

                    <p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RDD转化操作（键值元素）包括：</p>
                    <ol>
                        <li><b>groupByKey：</b>将RDD的每个元素按照键来分组，并返回新的键值对型RDD</li>
                        <li><b>reduceByKey：</b>将RDD的每个元素按照键来分组，然后执行函数操作，并返回新的键值对型RDD</li>
                        <li><b>mapValue：</b>将函数作用于RDD的每个元素的值上，并返回新的键值对型RDD</li>
                        <li><b>join：</b>根据键进行内连接，连接两个RDD,并返回新的键值对型RDD</li>
                        <li><b>leftOuterJoin：</b>根据键进行左连接，连接两个RDD,并返回新的键值对型RDD</li>
                        <li><b>rightOuterJoin：</b>根据键进行右连接，连接两个RDD,并返回新的键值对型RDD</li>
                        <li><b>key：</b>返回一个仅包括键的元素型RDD</li>
                        <li><b>values：</b>返回一个仅包含值的元素型RDD</li>
                        <li><b>sortByKey：</b>根据键来对元素排序</li>

                    </ol>

                    <p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RDD行动操作包括：</p>
                    <ol>
                        <li><b>collect：</b>返回RDD的所有元素（注意：超大规模RDD不应调用此命令）</li>
                        <li><b>take：</b>返回RDD的指定多个元素（返回顺序不确定）</li>
                        <li><b>top：</b>返回RDD的指定多个元素（返回顺序确定）</li>
                        <li><b>count：</b>返回RDD里的元素个数</li>
                        <li><b>countByValue：</b>某元素在RDD出现的次数</li>
                        <li><b>reduce：</b>并行规约所有RDD的数据</li>
                        <li><b>saveAsTextFile：</b>保存到文件系统</li>
                        <li><b>saveAsSequenceFile：</b>以SequenceFile形式保存到HDFS</li>
                        <li><b>saveAsObjectFile：</b>将RDD序列化为对象并保存到文件</li>

                    </ol>
                    <h4>RDD 创建</h4>
                    <p>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JavaSparkContext：JavaSparkContext是SparkContext的Java版本，
                        可看做Spark编程的入口，它表示应用程序和Spark集群的连接，可用来创建RDD。
                    </p>
                    <div class="code"><br>JavaSparkContext sc = new JavaSparkContext("yarn-client","SparkApp");<br>
                    </div>
                    <p>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中，参数一表示运行方式，另一个是应用的名称。
                    </p>
                    <div class="code"><br>sc.parallelize(List(1,2,3,4,5,6,7,8,9,10));<br></div>
                    <div class="code"><br>sc.textFile("hdfs://");<br></div>
                    <div class="code"><br>sc.textFile("file:/");<br></div>
                    <p>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的代码演示了从Java数据结构类、HDFS、本地文件系统来创建RDD。
                    </p>

                    <h4>参数传递</h4>
                    <p>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在执行RDD算子时，经常需要传入参数或返回结果。相对于Scala和Python，
                        Java对RDD操作时进行的参数传递相对麻烦一点，需借助function包中的接口完成。
                    </p>
                    <p>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. Function&lt;T, R&gt;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接收输入值T，返回输出值R<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例：filter、map<br>
                    </p>
                    <p>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. Function&lt;T1, T2, R&gt;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接收输入值T1，T2，返回输出值R<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例：aggregate、fold<br>
                    </p>
                    <p>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. FlatMapFunction&lt;T, R&gt;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接收输入值T，返回输出值集合迭代器Iterator&lt;R&gt;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例：flatMap<br>
                    </p>
                    <p>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4. DoubleFlatMapFunction&lt;T, R&gt;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接收输入值T，返回输出值集合迭代器Iterator&lt;R&gt;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例：flatMapToDouble<br>
                    </p>
                    <p>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5. PairFunction&lt;T, K, V&gt;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接收输入值T，返回输出值键值对&lt;K, V&gt;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例：mapToPair<br>
                    </p>

                    <h4>使用技巧</h4>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I.
                        行动操作不宜太多，每次行动操作都会为之前的TaskSet划分为一个Job，之前的Task并不释放，占用内存，影响GC效率。</p>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;II. 做join的时候，尽量用小RDD去join大RDD，用大RDD去join超大的RDD。</p>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;III.
                        避免collect的使用。当数据集规模较大时，会通过各个work进行收集，io增多，拉低性能，因此当数据集很大时应该save到HDFS。</p>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IV.
                        当RDD需要配合后续行动操作的迭代，最好先cache起来，但当RDD较大时，为防止内存溢出或必要历史数据擦除，应使用persist(MEMORY_AND_DISK)</p>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V. 不要重复创建RDD，并尽量复用已创建好的RDD</p>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VI.
                        Spark任务中最消耗性能的过程是shuffle，shuffle会把分布在多个节点的数据集中在一个节点上，会引起较大的IO、网络开销，
                        因此应尽量避免引起shuffle的操作，常见的有join、reduceByKey、distinct和reparation
                    </p>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VII. 不要重复创建RDD，并尽量复用已创建好的RDD</p>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VIII. 使用map-side预聚合的shuffle操作</p>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IX. 使用高性能算子，使用优先级：</p>
                    <ol>
                        <li>mapPartitions > map</li>
                        <li>foreachPartitions > foreach</li>
                        <li>repartitionAndSortWithinPartitions > repartition、sort</li>
                    </ol>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X. 当算子中需要传入大变量时，考虑使用Spark广播功能</p>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XI. 使用基本类型（int、long、数组）来替代字符串、集合（HashMap、ArrayList）、对象</p>


                </div>
                <div class="clear"></div>
            </article>

        </section>

        <aside class="prefix_1 grid_5">

            <!-- Categories-->
            <h4>Categories</h4>
            <ul class="categories">
                <li><a href="../../../page/list/lang.html">语言</a></li>
                <li><a href="../../../page/list/algorithm.html">算法</a></li>
                <li><a href="../../../page/list/framework.html">框架</a></li>
                <li><a href="../../../page/list/database.html">数据库</a></li>
                <li><a href="../../../page/list/arch.html">架构</a></li>
                <li><a href="../../../page/list/jvm.html">虚拟机</a></li>
                <li><a href="../../../page/list/bigdata.html">大数据</a></li>
                <li><a href="../../../page/list/tool.html">工具</a></li>
            </ul>
            <div class="clear"></div>
            <hr>

            <!-- article -->
            <h4>Articles</h4>
            <ul class="blogroll">
                <li><a href="../../../page/article/database/1-1.html">MySql性能优化</a></li>
                <li><a href="../../../page/article/database/1-2.html">Binary Log简介</a></li>
                <li><a href="../../../page/article/arch/1-1.html">分布式服务框架概述</a></li>
                <li><a href="../../../page/article/arch/1-2.html">通信框架设计：技术选型和可靠性</a></li>
                <li><a href="../../../page/article/bigdata/1-1.html">Spark快速入门</a></li>
                <li><a href="../../../page/article/jvm/1-1.html">JVM基础知识概述</a></li>
                <li><a href="../../../page/article/lang/1-2.html">理解Java线程池</a></li>
                <li><a href="#">最近发布</a></li>
                <li><a href="#">最近发布</a></li>
                <li><a href="#">最近发布</a></li>
                <li><a href="#">最近发布</a></li>
                <li><a href="#">最近发布</a></li>
                <li><a href="#">最近发布</a></li>
                <li><a href="#">最近发布</a></li>
            </ul>
            <hr>

        </aside>
    </div>
</div>

<!-- footer -->
<footer>
    <section id="footer_content">
        <div class="container_12">

        </div>
    </section>
    <section id="powered">
        <div class="container_12">
            <p class="grid_10"> code craft by <a href="https://lucifiere.github.io/"
                                                 title="王贤兑的博客" target="_blank"> XD.Wang </a></p>
            <p class="grid_2"><a class="top" href="#">▲ Back to top</a></p>
        </div>
    </section>
</footer>
</body>
</html>